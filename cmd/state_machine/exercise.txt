Pre-exercise
    1.
        Move functionality to separate function (red(), amber(), green())

Exercises
    1.
        New Requirement from the municipality

        The TrafficLight must not have a method of giving tickets if a red light is crossed.
        method gets the current passing car's speed and is called from a speed system deployed at the traffic light.

         Helper:
            func (tl *SimpleTrafficLight) CarPassingSpeed(kmt int, license plate string){}

    2.
        Add functionality to flash the light (of the current state color) if a car is a yellow mercedes.
        The warning speed threshold needed to trigger is different
        depending on which light is active (green, amber or red. red_amber cannot flash).

        Helper:
            func (tl *TrafficLight) FlashSpeedingCar(speed int){}

    3.
        Add a sensor that triggers when an ambulance approaches the traffic light.
        The sensor must alter the functionality of the traffic light and affect both draw and operation methods.
        ONLY red light in all directions should be active to allow safe passage of ambulance when the sensor is active.

    4.
        Now add crosswalk sensor.
        Cannot change to green if people are on the cross walk.

Post Dialogue

    Advantages
        The design pattern moves all state-related logic to a separate class thus reducing the coupling with the main
        context class & is following the Single Responsibility Principle State-related behaviour is declared in an
        interface. New states can be easily introduced without the need to modify & add conditional blocks of code.
        Code becomes open for extension & closed for modification

    Disadvantages
        Individual states must be aware of the next states and those states need to be hardcoded
        The pattern becomes an overkill if the design only has one or two states or the state behaviour rarely changes
        Note:- You might find the State design pattern similar to the Strategy design pattern which was discussed in my
        last post here. The only difference is that in Strategy, the concrete strategy classes are not aware of each
        other whereas, in State pattern, the current state should be aware of the next state.

References
    https://medium.com/swlh/vending-machine-design-a-state-design-pattern-approach-5b7e1a026cd2
    https://medium.com/swlh/stop-using-if-else-statements-f4d2323e6e4
    https://medium.com/swlh/5-ways-to-replace-if-else-statements-857c0ff19357
    https://levelup.gitconnected.com/if-else-is-a-poor-mans-polymorphism-ab0b333b7265
